# 신일 PMS API 문서 (v1.0)

**문서 버전: 1.0 (2025-01-15)**

## 1. 개요

본 문서는 신일 PMS(성과 관리 시스템)의 **실적 데이터 조회/필터링 API**에 대한 상세한 사용법과 예시를 제공합니다. 이 API는 Supabase Edge Functions를 기반으로 구축되었으며, 시스템의 핵심 데이터인 실적 정보를 JSON 형식으로 조회할 수 있습니다.

### 1.1. API 특징

- **RESTful 설계**: 표준 HTTP 메서드와 상태 코드 사용
- **유연한 필터링**: 다양한 조건으로 데이터 조회 가능
- **페이지네이션 지원**: 대용량 데이터 처리 최적화
- **CORS 지원**: 웹 애플리케이션에서 안전한 호출
- **JWT 인증**: 보안성 확보

---

## 2. API 엔드포인트

### 2.1. 기본 정보

```
POST /functions/v1/performance-data
```

**Base URL**: `https://[YOUR_PROJECT_ID].supabase.co`

### 2.2. 인증 요구사항

모든 API 호출에는 유효한 Supabase JWT 토큰이 필요합니다.

```http
Authorization: Bearer YOUR_JWT_TOKEN
Content-Type: application/json
```

---

## 3. 요청 파라미터

### 3.1. 필터 옵션 (모든 파라미터는 선택사항)

| 파라미터 | 타입 | 설명 | 예시 값 |
|---------|------|------|---------|
| `settlement_month_id` | number | 정산월 ID | `1` |
| `company_id` | string | 업체 UUID | `"123e4567-e89b-12d3-a456-426614174000"` |
| `client_id` | number | 거래처 ID | `100` |
| `product_id` | string | 제품 UUID | `"123e4567-e89b-12d3-a456-426614174001"` |
| `user_edit_status` | string | 검수 상태 | `"완료"`, `"검수중"`, `"대기"` |
| `record_type` | string | 실적 유형 | `"wholesale"`, `"direct"` |
| `date_from` | string | 시작일 (YYYY-MM-DD) | `"2024-01-01"` |
| `date_to` | string | 종료일 (YYYY-MM-DD) | `"2024-12-31"` |
| `limit` | number | 조회 개수 (기본값: 50) | `100` |
| `offset` | number | 시작 위치 (기본값: 0) | `50` |

### 3.2. 필터 조합 예시

```json
{
  "user_edit_status": "완료",
  "record_type": "wholesale",
  "date_from": "2024-01-01",
  "date_to": "2024-01-31",
  "limit": 100,
  "offset": 0
}
```

---

## 4. 응답 형식

### 4.1. 성공 응답 (HTTP 200)

```json
{
  "success": true,
  "data": [
    {
      "id": 1,
      "settlement_month_id": 1,
      "company_id": "123e4567-e89b-12d3-a456-426614174000",
      "client_id": 100,
      "product_id": "123e4567-e89b-12d3-a456-426614174001",
      "prescription_qty": 50,
      "amount": 1000000,
      "commission_rate": 0.05,
      "record_type": "wholesale",
      "user_edit_status": "완료",
      "created_at": "2024-01-15T10:30:00Z",
      "companies": {
        "company_name": "신일제약",
        "company_type": "제약사"
      },
      "clients": {
        "name": "서울대병원",
        "hospital_number": "H001"
      },
      "products": {
        "product_name": "아스피린",
        "insurance_code": "P001",
        "price": 20000
      },
      "settlement_months": {
        "settlement_month": "2024-01"
      }
    }
  ],
  "total_count": 150,
  "filter_applied": {
    "user_edit_status": "완료",
    "limit": 50,
    "offset": 0
  },
  "timestamp": "2024-01-15T10:30:00Z"
}
```

### 4.2. 에러 응답 (HTTP 400/500)

```json
{
  "error": "query_error",
  "message": "에러 메시지",
  "details": "상세 에러 정보"
}
```

---

## 5. 사용 예시

### 5.1. JavaScript Fetch API 사용

```javascript
// 완료된 실적 데이터 조회
async function fetchCompletedPerformance() {
  const response = await fetch('https://your-project.supabase.co/functions/v1/performance-data', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${jwtToken}`
    },
    body: JSON.stringify({
      user_edit_status: '완료',
      limit: 100
    })
  })
  
  const data = await response.json()
  return data
}

// 특정 업체의 도매 실적 조회
async function fetchCompanyWholesaleData(companyId) {
  const response = await fetch('https://your-project.supabase.co/functions/v1/performance-data', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${jwtToken}`
    },
    body: JSON.stringify({
      company_id: companyId,
      record_type: 'wholesale',
      date_from: '2024-01-01',
      date_to: '2024-01-31'
    })
  })
  
  const data = await response.json()
  return data
}
```

### 5.2. Vue.js Composable 패턴

```javascript
// composables/usePerformanceAPI.js
import { ref } from 'vue'
import { supabase } from '@/supabase'

export function usePerformanceAPI() {
  const loading = ref(false)
  const error = ref(null)
  const data = ref([])
  const totalCount = ref(0)

  const fetchPerformanceData = async (filters = {}) => {
    loading.value = true
    error.value = null
    
    try {
      const { data: response, error: apiError } = await supabase.functions.invoke('performance-data', {
        body: filters
      })
      
      if (apiError) throw apiError
      
      data.value = response.data
      totalCount.value = response.total_count
      
    } catch (err) {
      error.value = err.message
    } finally {
      loading.value = false
    }
  }

  return {
    loading,
    error,
    data,
    totalCount,
    fetchPerformanceData
  }
}
```

### 5.3. Vue 컴포넌트에서 사용

```vue
<template>
  <div class="performance-data">
    <!-- 필터 컨트롤 -->
    <div class="filters">
      <select v-model="filters.user_edit_status">
        <option value="">전체 상태</option>
        <option value="완료">완료</option>
        <option value="검수중">검수중</option>
        <option value="대기">대기</option>
      </select>
      
      <select v-model="filters.record_type">
        <option value="">전체 유형</option>
        <option value="wholesale">도매</option>
        <option value="direct">직거래</option>
      </select>
      
      <button @click="loadData" :disabled="loading">
        {{ loading ? '로딩 중...' : '데이터 조회' }}
      </button>
    </div>

    <!-- 에러 메시지 -->
    <div v-if="error" class="error-message">
      {{ error }}
    </div>

    <!-- 데이터 표시 -->
    <div v-if="data.length > 0" class="data-display">
      <p>총 {{ totalCount }}개의 데이터</p>
      
      <div class="data-table">
        <div v-for="item in data" :key="item.id" class="data-row">
          <div class="company">{{ item.companies.company_name }}</div>
          <div class="product">{{ item.products.product_name }}</div>
          <div class="client">{{ item.clients.name }}</div>
          <div class="amount">{{ formatAmount(item.amount) }}</div>
          <div class="status">{{ item.user_edit_status }}</div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive } from 'vue'
import { usePerformanceAPI } from '@/composables/usePerformanceAPI'

const { loading, error, data, totalCount, fetchPerformanceData } = usePerformanceAPI()

const filters = reactive({
  user_edit_status: '',
  record_type: '',
  limit: 50
})

const loadData = async () => {
  // 빈 값 제거
  const cleanFilters = Object.fromEntries(
    Object.entries(filters).filter(([_, value]) => value !== '')
  )
  
  await fetchPerformanceData(cleanFilters)
}

const formatAmount = (amount) => {
  return new Intl.NumberFormat('ko-KR').format(amount)
}
</script>
```

---

## 6. 배포 및 운영

### 6.1. Supabase CLI를 통한 배포

```bash
# 1. Supabase CLI 설치
npm install -g supabase

# 2. Supabase에 로그인
supabase login

# 3. 프로젝트 디렉토리로 이동
cd vue-project

# 4. 함수 배포
supabase functions deploy performance-data
```

### 6.2. 환경 변수 설정

Supabase Dashboard에서 다음 환경 변수가 설정되어 있는지 확인:

- `SUPABASE_URL`: 프로젝트 URL
- `SUPABASE_SERVICE_ROLE_KEY`: 서비스 롤 키

### 6.3. 권한 설정

API 함수가 데이터베이스에 접근할 수 있도록 적절한 RLS(Row Level Security) 정책이 설정되어 있어야 합니다.

---

## 7. 성능 최적화

### 7.1. 쿼리 최적화

- **인덱스 활용**: 자주 사용되는 필터 조건에 대한 인덱스 생성
- **페이지네이션**: 대용량 데이터 조회 시 `limit`과 `offset` 사용
- **필터 조합**: 필요한 조건만 조합하여 쿼리 최적화

### 7.2. 캐싱 전략

```javascript
// 간단한 메모리 캐싱 예시
const cache = new Map()

const fetchWithCache = async (filters) => {
  const cacheKey = JSON.stringify(filters)
  
  if (cache.has(cacheKey)) {
    return cache.get(cacheKey)
  }
  
  const data = await fetchPerformanceData(filters)
  cache.set(cacheKey, data)
  
  // 5분 후 캐시 삭제
  setTimeout(() => cache.delete(cacheKey), 5 * 60 * 1000)
  
  return data
}
```

---

## 8. 에러 처리 및 디버깅

### 8.1. 일반적인 에러 코드

| 에러 코드 | 의미 | 해결 방법 |
|----------|------|----------|
| `query_error` | 데이터베이스 쿼리 오류 | 필터 조건 확인, 권한 확인 |
| `server_error` | 서버 내부 오류 | 로그 확인, 관리자 문의 |
| `auth_error` | 인증 오류 | JWT 토큰 유효성 확인 |

### 8.2. 디버깅 방법

```javascript
// 상세한 에러 정보 로깅
const fetchWithDebug = async (filters) => {
  try {
    console.log('요청 필터:', filters)
    
    const response = await fetch('/functions/v1/performance-data', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${jwtToken}`
      },
      body: JSON.stringify(filters)
    })
    
    console.log('응답 상태:', response.status)
    
    const data = await response.json()
    console.log('응답 데이터:', data)
    
    return data
  } catch (error) {
    console.error('API 호출 에러:', error)
    throw error
  }
}
```

---

## 9. 향후 개선 계획

### 9.1. 추가 기능

- **실시간 업데이트**: WebSocket을 통한 실시간 데이터 동기화
- **고급 필터링**: 복합 조건, 정규식 검색 등
- **데이터 내보내기**: CSV, Excel 형식으로 데이터 내보내기
- **통계 API**: 집계 데이터 조회 API 추가

### 9.2. 성능 개선

- **Redis 캐싱**: 자주 조회되는 데이터 캐싱
- **쿼리 최적화**: 복잡한 조인 쿼리 최적화
- **CDN 활용**: 정적 데이터 전송 최적화

---

## 10. 연락처 및 지원

API 사용 중 문제가 발생하거나 개선 사항이 있으시면 다음으로 연락해 주세요:

- **개발팀**: [개발팀 이메일]
- **기술 문서**: [문서 링크]
- **이슈 트래커**: [GitHub Issues]

---

**문서 최종 업데이트**: 2025-01-15
**API 버전**: 1.0
**작성자**: 신일 PMS 개발팀 